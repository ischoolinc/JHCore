# 匯入課程基本資料 主要程式碼結構與流程

## 1. 主要匯入流程
- **檔案**：`CourseExtendControls/Ribbon/CourseImportWizard.cs`
- **類別**：`CourseImportWizard`
- **重點方法**：
  - `btnImport_Click`：按下「匯入」按鈕時的主流程，將 Excel/檔案資料轉成 XML，並呼叫資料存取層進行匯入。
  - `GenerateInsertXml`、`GenerateUpdateXml`：將每一列資料轉成 XML 結構。
  - `ConvertClassField`、`ConvertTemplateField`：處理班級、評量設定等特殊欄位的轉換。
  - `UpdateTeacherInformation`：處理課程教師的匯入。

---

## CourseImportWizard.cs 詳細流程解析

### 1. UI 操作流程
- 使用者依序操作精靈（Wizard）：
  1. **選擇檔案與匯入模式**（Insert/Update）
     - `btnSelectFile_Click`：選擇來源檔案。
     - `wpSelectFileAndAction_NextButtonClick`：檢查檔案、模式、載入欄位規格。
  2. **選擇識別欄位與驗證欄位**（僅 Update 模式）
     - `wpCollectKeyInfo_AfterPageDisplayed`：載入可用識別欄位、驗證欄位。
     - `wpCollectKeyInfo_NextButtonClick`：檢查選擇正確性。
  3. **選擇要匯入的欄位**
     - `wpSelectField_AfterPageDisplayed`：載入來源檔案欄位，檢查必要欄位，顯示於 ListView。
     - `wpSelectField_NextButtonClick`：記錄使用者勾選的欄位，並根據欄位決定是否載入班級、教師、評量設定的 lookup。
  4. **資料驗證**
     - `btnValidate_Click`：執行驗證，呼叫 `ValidateHelper`，依據欄位規則與 row 規則檢查資料正確性。
     - 驗證結果顯示於 UI，錯誤需修正後才能繼續。
  5. **匯入資料**
     - `btnImport_Click`：將資料轉成 XML，呼叫 `ImportDataAccess` 進行 Insert/Update。
     - 處理特殊欄位（班級、評量設定、教師）轉換與更新。
     - 匯入完成後，觸發同步與 UI 更新。

### 2. 主要資料流動
- **來源檔案**：Excel 由 `SheetHelper` 解析，取得欄位與資料。
- **欄位規格**：由 `ImportDataAccess.GetImportFieldList()` 取得 XML 規格，產生 `ImportFieldCollection`。
- **驗證**：
  - 欄位驗證（如教師存在性）與 row 驗證（如教師重覆）由 `ValidateHelper` 執行。
  - 驗證規則來自 XML 設定檔。
- **資料轉換**：
  - 依 Insert/Update 模式，將每列資料轉成 XML 結構。
  - 特殊欄位（班級、評量設定、教師）需額外查表轉換。
- **匯入**：
  - Insert/Update 由 `ImportDataAccess` 呼叫 SmartSchool API 完成。
  - 教師資料需先移除舊有，再新增新教師。

### 3. 重要類別與物件
- `WizardContext`：保存精靈操作過程中的所有狀態（來源檔案、模式、欄位、lookup 等）。
- `ImportDataAccess`：負責與 SmartSchool API 溝通，執行資料 Insert/Update。
- `SheetHelper`：解析 Excel 檔案。
- `ImportFieldCollection`、`ImportCondition`：描述欄位規格與識別條件。
- `TeacherLookup`、`ClassLookup`、`TemplateLookup`：特殊欄位的查表物件。

### 4. 例外處理與 UI 回饋
- 各步驟皆有 try-catch，錯誤時以 MsgBox 顯示。
- 匯入與驗證過程有進度條與訊息提示。
- 匯入完成後自動同步課程資料。

---

## 2. 資料存取層
- **檔案**：`CourseExtendControls/Ribbon/CourseImportWizardControls/ImportDataAccess.cs`
- **類別**：`ImportDataAccess`
- **重點方法**：
  - `InsertImportData(XmlElement data)`：呼叫 `SmartSchool.Feature.Course.CourseBulkProcess.InsertImportCourse` 實際將資料匯入。
  - `UpdateImportData(XmlElement data)`：呼叫 `SmartSchool.Feature.Course.CourseBulkProcess.UpdateImportCourse` 進行更新。
  - 其他方法則負責取得欄位規則、驗證規則、主鍵等。

## 3. 欄位規格與驗證
- **資源檔**：`Resources/JH_Course_ImportFieldList.xml`、`Resources/JH_Course_FieldValidationRule.xml`
  - 這些 XML 檔案定義了匯入時可用的欄位與驗證規則。

## 4. 驗證流程與 ValidateHelper 詳解

### 1. 主要角色
- **類別**：`Legacy/ImportSupport/ValidateHelper.cs` 的 `ValidateHelper`
- **用途**：負責將驗證規則(XML)載入、初始化所有欄位與列的 Validator，並逐行執行驗證，彙整所有錯誤、警告、修正建議，回傳給 UI 顯示。

### 2. 運作流程
1. **初始化**：
   - 由 `CourseImportWizard` 的 `btnValidate_Click` 事件建立 `ValidateHelper` 實例，傳入 `WizardContext`（保存精靈狀態）與 Validator Factory（產生各種驗證器）。
   - 內部會建立 `DocumentValidate` 物件，並註冊所有欄位與列的驗證器（Validator）。
2. **載入驗證規則**：
   - 依據是否有高雄自動編班模組，載入不同的 XML 驗證規則（`JH_C_ImportValidatorRule_KH` 或 `JH_C_ImportValidatorRule`）。
   - 驗證規則 XML 會定義所有欄位與列的驗證方式（如必填、格式、唯一、教師重覆等）。
   - 透過 `InitFromXMLNode` 解析 XML，註冊對應的 Validator。
3. **執行驗證**：
   - 逐行（row）呼叫 `ValidateRow`，每一行都會依據規則執行所有欄位與列的驗證。
   - 驗證過程中，若有錯誤、警告、或自動修正，會觸發事件（`ErrorCaptured`、`AutoCorrect`），由 `ValidateHelper` 收集並記錄於 `CellCommentManager`。
   - 驗證進度會回報給 UI（進度條、可取消）。
   - 若為 Update 模式，還會額外檢查資料庫唯一性，合併額外的錯誤訊息。
4. **回傳結果**：
   - 驗證結束後，所有錯誤、警告、修正建議都會以 `CellCommentManager` 物件回傳，供 UI 標示於 Excel 表格。

### 3. 與 XML 驗證規則的關聯
- 驗證規則（XML）可於資源檔維護，方便日後調整。
- 新增/修改驗證規則時，無須改動主程式碼，只需調整 XML。
- 支援欄位驗證（FieldValidator）、列驗證（RowValidator），可彈性擴充。

### 4. 主要成員說明
- `_validator`：`DocumentValidate` 實例，負責驗證主流程。
- `_valid_factory`：產生各種 Validator 的工廠，支援自訂規則。
- `_comments`：收集所有驗證訊息（錯誤、警告、修正）。
- `Validate(SheetHelper sheet)`：主驗證入口，回傳所有驗證結果。
  - 2024/07：已改為根據 `WizardContext.EntityType` 判斷匯入類型與驗證規則，取代原本以 `Extensions` 判斷 `importType` 的方式，程式碼更單一、可維護。

### 5. 小結
- `ValidateHelper` 將驗證規則與驗證邏輯解耦，讓驗證流程可配置、可擴充。
- 驗證結果可即時回饋 UI，提升使用者體驗。

---

## 4. 實際匯入的核心
- **呼叫路徑**：
  - UI → `CourseImportWizard` → `ImportDataAccess` → `SmartSchool.Feature.Course.CourseBulkProcess`

---

> 可從 `CourseImportWizard.cs` 的 `btnImport_Click` 方法開始追蹤，這裡會依據使用者選擇的檔案與欄位，組成 XML，然後呼叫 `ImportDataAccess` 進行實際匯入。 

---

## 教師驗證方式

### 1. 欄位驗證
- **欄位**：授課教師一、授課教師二、授課教師三
- **規則**：
  - 這三個欄位都會進行「合法教師驗證」，即必須存在於系統教師名單中。
  - 驗證規則定義於 `Resources/JH_Course_FieldValidationRule.xml`：
    ```xml
    <FieldValidator Name="合法教師驗證" SkipEmpty="True" Type="TeacherLookup">
      <ActivatorField>授課教師一</ActivatorField>
      <ActivatorField>授課教師二</ActivatorField>
      <ActivatorField>授課教師三</ActivatorField>
    </FieldValidator>
    ```

### 2. 教師重複檢查（Row 驗證）
- **規則**：
  - 同一課程的「授課教師一、二、三」不可重複（同一教師不能在同一課程擔任多個授課序號）。
  - 驗證規則定義於 `Resources/JH_Course_FieldValidationRule.xml`：
    ```xml
    <RowValidator Name="教師重覆驗證" Type="TeacherDuplicateCheck">
      <ActivatorField>授課教師一</ActivatorField>
      <ActivatorField>授課教師二</ActivatorField>
      <ActivatorField>授課教師三</ActivatorField>
    </RowValidator>
    ```
- **程式碼**：
  - `CourseImportWizardControls/TeacherDuplicateRowValidator.cs` 內的 `TeacherDuplicateRowValidator` 類別負責此驗證。
  - 驗證邏輯：
    - 逐行檢查三個教師欄位，若有重複即回報錯誤。
    - 更新模式下，會比對資料庫現有教師資料與本次匯入資料，確保不重複。

### 3. 驗證觸發時機
- 欄位驗證與重複檢查會在匯入精靈的「驗證」步驟自動執行。
- 若驗證失敗，使用者需修正資料後才能繼續匯入。

--- 

# TeacherDuplicateRowValidator.Validate() 未被執行之檢查紀錄

## 問題描述
在匯入課程精靈中，點選「開始驗證」時，發現 `TeacherDuplicateRowValidator` 的 `Validate()` 方法沒有被執行。

## 檢查結果

1. **Validator 是否有被註冊/加入驗證流程？**
   - 有。`CourseImportWizard` 內的 `CourseRowValidatorFactory` 會根據 XML 設定產生 `TeacherDuplicateRowValidator` 實例。
   - 驗證規則 XML (`JH_Course_FieldValidationRule.xml`) 有 `<RowValidator Name="教師重覆驗證" Type="TeacherDuplicateCheck">`，且在 `<RowValidate>` 區段有啟用。

2. **驗證流程是否有正確呼叫每個 Validator 的 Validate()?**
   - 有。`btnValidate_Click` 事件會呼叫 `ValidateHelper.Validate(sheet)`，而 `ValidateHelper` 會初始化所有 RowValidator，並逐行呼叫 `ValidateRow`，進而呼叫每個 validator 的 `Validate()`。

3. **_activate_validator 是否為 true？**
   - 此欄位會在 `InitFromXMLNode` 依據 ActivatorField 是否有被選取來決定。
   - XML 設定有三個 ActivatorField（授課教師一、二、三）。
   - 若匯入欄位時未勾選這三個欄位，`_activate_validator` 會是 false，`Validate()` 會直接 return true，不會執行檢查。

4. **匯入模式與資料來源**
   - `TeacherDuplicateRowValidator` 會根據 `ImportMode` 決定驗證邏輯，context 初始化時已正確傳遞。

5. **事件觸發與 UI 綁定**
   - `btnValidate_Click` 事件有正確呼叫驗證流程，UI 綁定無誤。

## 結論與建議
- 最常見原因：在「選擇匯入欄位」時，未勾選「授課教師一」、「授課教師二」、「授課教師三」其中之一，導致 `_activate_validator = false`，`Validate()` 直接 return true。
- 請確認匯入精靈的欄位選擇頁面，有勾選至少一個授課教師欄位。
- 若仍未進入 `Validate()`，可於方法最前方加上 Debug log 觀察。

---

> 本紀錄供日後追蹤 TeacherDuplicateRowValidator 驗證流程問題參考。 

---

## 2025/07/28 教師重覆檢查修正紀錄

### 問題
- 原本教師重覆檢查（TeacherDuplicateRowValidator）在遇到空值時，會把多個空值當成重覆，導致只要有兩個空白教師欄位就被判定為重覆，這不合理。
- Update 模式下，原本資料與新資料合併時，空值也會被當成重覆。

### 修正內容
- 修改 IsValid 方法，空值（null 或空字串）不檢查重覆，有值才檢查。
- 這樣只有同一課程的同一位教師（有值且重覆）才會被判定為重覆。

### 修正後程式片段
```csharp
// 只顯示重點片段
if (string.IsNullOrEmpty(value)) continue; // 空值不檢查
if (dup.ContainsKey(value))
    return false;
```

### 結論
- 修正後，只有有值且重覆的教師才會被判定為重覆，空白欄位不會誤判。 

---

## 2024/05/10 TeacherLookup 欄位名稱比對與驗證流程修正紀錄

### 問題
- 若 Excel 欄位名稱有多餘空白或全半形不同，TeacherLookup 可能無法正確啟動，導致不存在的教師未被擋下。

### 修正內容
- 在 TeacherLookupFieldValidator 與 CourseImportWizard.cs 欄位名稱比對時，統一使用 Trim() 去除前後空白，避免因欄位名稱不一致導致驗證失效。
- 在 TeacherLookupFieldValidator.Validate 方法加上 log，方便追蹤驗證是否有被呼叫。

### 結論
- 修正後，Excel 欄位名稱只要內容正確（即使有多餘空白），TeacherLookup 也能正確啟動並驗證。
- 驗證流程 log 可協助日後除錯。 

---

## 5. 授課教師驗證物件建立流程

### 1. 程式碼片段
```csharp
if (fields.Contains("授課教師一") || fields.Contains("授課教師二") || fields.Contains("授課教師三"))
{
    if (Context.Extensions.ContainsKey(TeacherLookup.Name))
        Context.Extensions.Remove(TeacherLookup.Name);

    Context.Extensions.Add(TeacherLookup.Name, new TeacherLookup());
}
```

### 2. 運作說明
- 此段程式碼出現在「選擇匯入欄位」頁面按下「下一步」時（wpSelectField_NextButtonClick）。
- 其作用是：
  - 只要有勾選「授課教師一」、「授課教師二」、「授課教師三」其中之一，
  - 就會建立一個 `TeacherLookup` 物件，放入 `Context.Extensions` 字典，供後續驗證器查詢。
- 若三個欄位都沒勾選，則不會建立 TeacherLookup，後續驗證器也不會啟動。

### 3. 與驗證流程的關聯
- TeacherLookupFieldValidator 會在初始化時，檢查 `SelectedFields` 是否有這三個欄位，若有才啟動驗證。
- 並從 `Context.Extensions` 取得 `TeacherLookup`，查詢教師名單。
- 驗證時，會逐行檢查「授課教師一、二、三」的值是否存在於 TeacherLookup 名單中。

### 4. 小結
- 此段程式碼本身**不會直接驗證**教師欄位，而是「準備」好教師查詢物件，讓驗證器能正確運作。
- 欄位沒勾選就不會驗證，這是授課教師驗證失效的最常見原因。

--- 

---

## 6. TeacherLookup.cs 程式碼解析

### 1. 類別用途
- `TeacherLookup` 主要用於「匯入課程」時，驗證授課教師欄位的教師名稱是否存在於系統教師名單中。
- 提供依據「姓名(暱稱)」或「姓名」查詢教師 ID 的功能，供驗證器（如 TeacherLookupFieldValidator）使用。

### 2. 主要資料結構
- 內部使用 `Dictionary<string, string> _teachers`，
  - Key: "姓名:暱稱"（如 "王小明:阿明"，若無暱稱則為 "王小明:"）
  - Value: 教師系統 ID
- 以此結構快速比對匯入資料中的教師名稱。

### 3. 建構流程
- 建構子會呼叫 `QueryTeacher.GetTeacherList()` 取得所有教師資料（XML 格式）。
- 逐一解析每個教師節點，取出 `TeacherName`、`Nickname`、`ID`，組成 key-value 加入 `_teachers` 字典。
- 例如：
  - 王小明（暱稱：阿明，ID:123）→ key: "王小明:阿明"，value: "123"
  - 李大華（無暱稱，ID:456）→ key: "李大華:"，value: "456"

### 4. 主要方法
#### (1) GetTeacherID(string teacherName)
- 依據傳入的教師名稱（可能為「姓名」或「姓名(暱稱)」格式），回傳對應教師 ID。
- 處理流程：
  1. 若名稱包含括號（如「王小明(阿明)」），用正規表示式 `_matcher` 解析出姓名與暱稱。
  2. 組成 key: "姓名:暱稱"，查詢 `_teachers` 字典。
  3. 若無括號，則 key 為 "姓名:"。
  4. 若找到則回傳 ID，否則回傳空字串。
- 例：
  - 輸入 "王小明(阿明)" → 解析為 key: "王小明:阿明" → 查詢 → 回傳 ID
  - 輸入 "李大華" → key: "李大華:" → 查詢 → 回傳 ID

#### (2) Contains(string teacherName)
- 判斷指定名稱的教師是否存在。
- 內部直接呼叫 `GetTeacherID`，只要回傳非空字串即代表存在。

#### (3) Name (靜態屬性)
- 回傳 "TeacherLookup"，供外部統一取用名稱（如 Context.Extensions 字典的 key）。

### 5. 正規表示式用途
- `_matcher = new Regex(@"^(?<Name>.*[^\(])\s*\(\s*(?<Nickname>.*[^\)])\)?$", RegexOptions.Singleline);`
- 用於解析「姓名(暱稱)」格式，將括號內外分別取出。
- 例：
  - "王小明(阿明)" → Name: "王小明"，Nickname: "阿明"
  - "李大華" → 不含括號，直接用 "李大華:" 查詢

### 6. 與匯入驗證流程的關聯
- 匯入精靈在「選擇匯入欄位」時，若有勾選授課教師欄位，會建立 `TeacherLookup` 實例，放入 Context.Extensions。
- 驗證器（TeacherLookupFieldValidator）會利用此物件，檢查每一筆匯入資料的教師名稱是否存在於系統名單。
- 若名稱格式正確且存在，則驗證通過；否則回報錯誤。

### 7. 小結
- `TeacherLookup` 將教師名單快取於記憶體，並支援「姓名」或「姓名(暱稱)」兩種查詢格式。
- 是匯入驗證流程中，教師欄位合法性檢查的核心物件。 

#### 2025/07/28 fullName 組成邏輯調整
- 原本 fullName 組成為 "姓名:暱稱"，現改為：
  - 有暱稱時：fullName = 姓名(暱稱)
  - 無暱稱時：fullName = 姓名
- 這樣可讓匯入資料的教師名稱格式與系統顯示一致，減少比對失敗的情形。
- 驗證時，若 Excel 欄位填寫「王小明(阿明)」或「李大華」，可正確對應到教師名單。
- 請注意：如有自動產生或舊資料，需同步調整名稱格式以確保驗證正確。 

#### 2025/07/28 fullName 格式調整補充
- 原本 fullName 組成為 `string.Format("{0}:{1}", name, nickname)`，即「姓名:暱稱」，無暱稱時為「姓名:」
- 現改為 `string.IsNullOrEmpty(nick) ? name : string.Format("{0}({1})", name, nick)`，即有暱稱時「姓名(暱稱)」，無暱稱時僅「姓名」
- 這樣可讓匯入資料、系統顯示、查詢與驗證流程的名稱格式完全一致，避免比對失敗。
- 請注意：查詢（如 GetTeacherID）也需用相同格式組成 fullName，才能正確比對。 

---

## 2024/07/08 TeacherLookup fullName 組成邏輯修正紀錄

### 問題
- 匯入課程時，若教師名稱格式為「姓名(暱稱)」或「姓名」，但 GetTeacherID 查詢時 fullName 組成方式與建構子不一致，會導致查不到教師。
- 例如：建構子用 "王小明(阿明)" 作為 key，但查詢時用 "王小明:阿明"，比對會失敗。

### 修正內容
- 將 GetTeacherID 方法內查詢 fullName 的組成邏輯，改為：
  - 有暱稱時：fullName = "姓名(暱稱)"
  - 無暱稱時：fullName = "姓名"
- 與建構子一致，確保匯入資料的教師名稱格式與系統一致，避免比對失敗。
- 也將 else 分支修正為直接取 teacherName.Trim()，避免多餘符號。

### 影響
- 匯入課程時，教師名稱只要與系統顯示一致（如「王小明(阿明)」或「李大華」），即可正確比對。
- 減少因名稱格式不一致導致的驗證失敗。

### 相關程式片段
```csharp
if (teacherName.IndexOf('(') >= 0)
{
    Match m = _matcher.Match(teacherName.Trim());
    string name = m.Groups["Name"].Value.Trim();
    string nickname = m.Groups["Nickname"].Value.Trim();
    fullName = string.IsNullOrEmpty(nickname) ? name : string.Format("{0}({1})", name, nickname);
}
else
    fullName = teacherName.Trim();
```

### 結論
- 修正後，TeacherLookup 的 fullName 組成方式於建構與查詢時完全一致，匯入驗證更穩定。 

---

## 2024/07/28 匯入來源判斷邏輯補充

### 調整內容
- 在 `Legacy/ImportSupport/ValidateHelper.cs` 的 `Validate(SheetHelper sheet)` 方法中，新增匯入來源判斷邏輯：
  - 若 `_context.Extensions.ContainsKey("TeacherLookup")`，代表本次匯入為「課程」。
  - 若 `_context.Extensions.ContainsKey("ClassLookup")`，代表本次匯入為「班級」。
  - 兩者皆無則視為「教師」。
- 方便日後除錯與維護時，能快速判斷目前驗證流程的來源。

### 程式片段
```csharp
// 判斷匯入來源
string importType = "教師";
if (_context.Extensions.ContainsKey("TeacherLookup"))
    importType = "課程"; // 課程匯入
else if (_context.Extensions.ContainsKey("ClassLookup"))
    importType = "班級"; // 班級匯入
// 可於此行加上 log 或 debug 用於追蹤
// 例如: Console.WriteLine($"[DEBUG] 匯入來源: {importType}");
```

### 補充說明
- 此判斷方式依據 WizardContext.Extensions 於不同匯入精靈流程中注入的 lookup 物件。
- 若需於驗證流程中依據來源做不同處理，可直接使用 `importType` 變數。
- 建議於除錯或維護時，於此處加上 log 以利追蹤。 

---

## 2024/07/28 驗證規則資源檔（JH_Course_FieldValidationRule、JH_T_FieldValidationRule）使用位置補充

### 1. JH_Course_FieldValidationRule
- **用途**：課程匯入時，作為欄位與列驗證規則的 XML 資源。
- **主要使用位置**：
  1. `Legacy/ImportSupport/ValidateHelper.cs`：
     - 依據匯入來源判斷為「課程」時，載入此 XML 作為驗證規則。
     - 片段：
       ```csharp
       if (importType == "課程")
       {
           XmlDocument doc = new XmlDocument();
           doc.LoadXml(Properties.Resources.JH_Course_FieldValidationRule);
           xmlRule = doc.DocumentElement;
       }
       ```
  2. `CourseExtendControls/Ribbon/CourseImportWizardControls/ImportDataAccess.cs`：
     - 方法 `GetValidateFieldRule()` 直接載入此資源，供驗證流程使用。
     - 片段：
       ```csharp
       public XmlElement GetValidateFieldRule()
       {
           XmlDocument doc = new XmlDocument();
           doc.LoadXml(Properties.Resources.JH_Course_FieldValidationRule);
           return doc.DocumentElement;
       }
       ```
  3. `Properties/Resources.Designer.cs`：
     - 自動產生的資源屬性，供程式取得內嵌 XML。

### 2. JH_T_FieldValidationRule
- **用途**：教師匯入時，作為欄位與列驗證規則的 XML 資源。
- **主要使用位置**：
  1. `Legacy/ImportSupport/ValidateHelper.cs`：
     - 依據匯入來源判斷為「教師」時，載入此 XML 作為驗證規則。
     - 片段：
       ```csharp
       if (importType == "教師")
       {
           XmlDocument doc = new XmlDocument();
           doc.LoadXml(Properties.Resources.JH_T_FieldValidationRule);
           xmlRule = doc.DocumentElement;
       }
       ```
  2. `Feature/Legacy/TeacherBulkProcess.cs`：
     - 方法 `GetFieldValidationRule()` 直接載入此資源，供驗證流程使用。
     - 片段：
       ```csharp
       public static XmlElement GetFieldValidationRule()
       {
           XmlDocument doc = new XmlDocument();
           doc.LoadXml(JHSchool.Properties.Resources.JH_T_FieldValidationRule);
           return doc.DocumentElement;
       }
       ```
  3. `Properties/Resources.Designer.cs`：
     - 自動產生的資源屬性，供程式取得內嵌 XML。

### 小結
- 這兩個資源檔分別於課程與教師匯入驗證流程中載入，作為驗證規則的來源。
- 主要用於 `ValidateHelper` 及各自的 Import/BulkProcess 相關類別，確保匯入資料符合規範。 

---

## 2024/07/28 學生驗證規則（JH_S_FieldValidationRule）與現有程式關聯補充

- `JH_S_FieldValidationRule` 為學生匯入時的欄位與列驗證規則 XML 資源。
- 其實際載入與使用僅出現在 `Feature/Legacy/StudentBulkProcess.cs` 的 `GetFieldValidationRule()` 方法：
  ```csharp
  public static XmlElement GetFieldValidationRule()
  {
      XmlDocument doc = new XmlDocument();
      doc.LoadXml(Properties.Resources.JH_S_FieldValidationRule);
      // ...動態補上合法班級名單...
      return doc.DocumentElement;
  }
  ```
- 學生匯入驗證流程（如 StudentImportWizard）會直接呼叫上述方法取得驗證規則。
- 目前 `Legacy/ImportSupport/ValidateHelper.cs` 只負責「班級」、「課程」、「教師」三種匯入流程的驗證規則載入，**與學生驗證規則（JH_S_FieldValidationRule）無直接關聯**。
- 因此，針對 ValidateHelper 的調整（如匯入來源判斷與規則載入），**不會影響學生匯入驗證流程**。 

---

## 2024/07/28 教師驗證規則（JH_T_FieldValidationRule）與 ValidateHelper.cs 關聯補充

- `JH_T_FieldValidationRule` 為教師匯入時的欄位與列驗證規則 XML 資源。
- 在 `Legacy/ImportSupport/ValidateHelper.cs` 的 `Validate(SheetHelper sheet)` 方法中，會根據 `_context.Extensions` 判斷匯入來源：
  - 若來源為「教師」，則載入 `JH_T_FieldValidationRule` 作為驗證規則。
  - 片段：
    ```csharp
    if (importType == "教師")
    {
        XmlDocument doc = new XmlDocument();
        doc.LoadXml(Properties.Resources.JH_T_FieldValidationRule);
        xmlRule = doc.DocumentElement;
    }
    ```
- 此驗證規則 XML 會定義教師匯入時的欄位、格式、唯一性等規則，並由 `ValidateHelper` 驗證教師資料正確性。
- 只要是教師匯入流程，會經過上述判斷與規則載入邏輯，並使用這個 XML 進行驗證。
- 另外，`JH_T_FieldValidationRule` 也會在 `Feature/Legacy/TeacherBulkProcess.cs` 的 `GetFieldValidationRule()` 方法中被載入，供教師匯入流程使用。
- **總結：JH_T_FieldValidationRule 是教師匯入驗證的核心規則檔，與 ValidateHelper.cs 有直接關聯。** 

## JH_C_ImportValidatorRule.xml 常見錯誤排查與正確格式說明

### 1. RowValidator Type 對應
JH_C_ImportValidatorRule.xml 中的 <RowValidator Type="..." /> 必須對應到程式端有實作的驗證器類別，例如：
- InsertDBUnique → InsertDBUniqueRowValidator
- InsertSheetUnique → InsertSheetUniqueRowValidator
- ShiftCheck → ShiftCheckRowValidator
- UpdateIdentify → UpdateIdentifyRowValidator
- UpdateUnique → UpdateUniqueRowValidator

這些類別通常位於 Legacy/ImportSupport/Validators/ 目錄下。

### 2. XML 檔案格式與編碼
- 檔案必須為 UTF-8（無 BOM）格式。
- 標籤需正確關閉，層級正確，無多餘或未轉義的特殊字元。
- 建議用 VSCode、Notepad++ 等工具檢查並重新存檔。

### 3. 常見錯誤與解決方式
- **Type 名稱錯誤**：Type 屬性拼錯或程式端無對應類別，會導致初始化失敗。
- **XML 格式錯誤**：如標籤未關閉、層級錯誤、不可見字元，會導致 XmlDocument.LoadXml() 失敗。
- **Validator 名稱對不到**：<Validate Validator="xxx" /> 指定的名稱在 <RowValidator Name="xxx" /> 沒有定義。

### 4. 排查建議
- 檢查 XML 檔案內容與格式，並用 XML 編輯器驗證。
- 檢查 Type 名稱與程式端類別是否一致。
- 如遇初始化錯誤，於程式端加上 try-catch 印出詳細例外訊息。 